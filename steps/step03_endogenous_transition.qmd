---
title: "Step 3 - Endogenous Transition"
format:
  html:
    toc: true
    number-sections: true
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
---

## Shared Setup

Load minimal packages and global options only.

Check that required packages are installed.
Stop early with a clear error if anything is missing.
This keeps the tutorial run deterministic and minimal.
```{r setup_packages}
required_packages <- c("jsonlite", "ggplot2")
missing_packages <- required_packages[!vapply(required_packages, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_packages) > 0) {
  stop("Missing package(s): ", paste(missing_packages, collapse = ", "), call. = FALSE)
}
```

### Dependency Context

This step is standalone: it reuses Step 2 data/calibration helpers.
Endogenous transition dynamics are defined here (not in helpers).

```{r source_helpers}
helper_dir <- if (dir.exists('R/helpers')) 'R/helpers' else '../R/helpers'
source(file.path(helper_dir, 'cache_io.R'))
source(file.path(helper_dir, 'jsonstat_parse.R'))
source(file.path(helper_dir, 'iot_load.R'))
source(file.path(helper_dir, 'config_wealth.R'))
source(file.path(helper_dir, 'calibration.R'))
```

## Step 3: Endogenous Transition

### Objective

Start from the fitted Step 2 baseline model and activate endogenous energy reallocation to study transition effects.

### Equations

- `signal_t = (X_green,t-1 - X_brown,t-1) / sum_i |X_i,t-1|`
- `shift_t = max(0, transition_speed * (1 + transition_signal_weight * signal_t))`
- `beta_C,brown,t = beta_C,brown,t-1 - shift_t`
- `beta_C,green,t = beta_C,green,t-1 + shift_t`

Rebuild Step 2 baseline objects in this standalone step.

For standalone execution, this hidden block recreates the fitted baseline path from Step 2.
It uses the same baseline dynamics (no transition) and then provides a comparison path for this step.
```{r step3_bootstrap_from_step2, include=FALSE}
simulate_sim_iot_baseline <- function(calib,
                                      T = 20,
                                      c_y = 0.82,
                                      c_v = 0.03,
                                      g_G = 0.01) {
  years <- calib$base_year + seq_len(T) - 1
  out <- data.frame(
    year = years,
    GDP = NA_real_, TAX = NA_real_, YD = NA_real_, C = NA_real_, G = NA_real_,
    V = NA_real_, DEF = NA_real_, B = NA_real_
  )

  V_prev <- calib$V0
  B_prev <- calib$B0
  G_prev <- calib$G0

  for (tt in seq_len(T)) {
    G_t <- if (tt == 1) calib$G0 else G_prev * (1 + g_G)

    k <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% calib$beta_C))
    b <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% (calib$beta_G * G_t + calib$I_i0)))
    den <- 1 - c_y * (1 - calib$tau_y) * k
    C_t <- max((c_y * (1 - calib$tau_y) * b + c_v * V_prev) / den, 0)

    fd_t <- calib$beta_C * C_t + calib$beta_G * G_t + calib$I_i0
    x_t <- pmax(as.numeric(calib$L %*% fd_t), 0)
    Y_t <- sum(calib$va_coeff * x_t)
    TAX_t <- calib$tau_y * Y_t
    YD_t <- Y_t - TAX_t

    V_t <- V_prev + YD_t - C_t
    DEF_t <- G_t - TAX_t
    B_t <- B_prev + DEF_t

    out[tt, c("GDP", "TAX", "YD", "C", "G", "V", "DEF", "B")] <- c(Y_t, TAX_t, YD_t, C_t, G_t, V_t, DEF_t, B_t)

    V_prev <- V_t
    B_prev <- B_t
    G_prev <- G_t
  }

  out
}

core_config <- make_core_config()
iot <- download_or_load_iot(core_config)
wealth_init <- load_wealth_init(core_config)
calib3 <- calibrate_sim_iot(iot, wealth_init)
step2_baseline <- simulate_sim_iot_baseline(calib3, T = 20)
```

Define Step 3 endogenous transition dynamics.

This is the new Step 3 algorithm: it adds endogenous brown/green share updates to the Step 2 macro-IO loop.
Everything else stays the same as baseline, so transition effects are isolated cleanly.
```{r step3_functions_endogenous_transition}
simulate_sim_iot_endogenous_transition <- function(calib,
                                                   T = 20,
                                                   c_y = 0.82,
                                                   c_v = 0.03,
                                                   g_G = 0.01,
                                                   transition_speed = 0.0015,
                                                   transition_signal_weight = 1) {
  years <- calib$base_year + seq_len(T) - 1
  out <- data.frame(
    year = years,
    GDP = NA_real_, TAX = NA_real_, YD = NA_real_, C = NA_real_, G = NA_real_,
    V = NA_real_, DEF = NA_real_, B = NA_real_, betaC_brown = NA_real_, betaC_green = NA_real_
  )

  V_prev <- calib$V0
  B_prev <- calib$B0
  G_prev <- calib$G0
  x_prev <- as.numeric(calib$L %*% (calib$beta_C * sum(calib$I_i0) + calib$beta_G * calib$G0 + calib$I_i0))
  beta_C <- calib$beta_C

  for (tt in seq_len(T)) {
    G_t <- if (tt == 1) calib$G0 else G_prev * (1 + g_G)

    if (is.finite(calib$idx$idx_green) && is.finite(calib$idx$idx_brown)) {
      signal <- (x_prev[calib$idx$idx_green] - x_prev[calib$idx$idx_brown]) / pmax(sum(abs(x_prev)), 1)
      shift <- max(0, transition_speed * (1 + transition_signal_weight * signal))
      shift <- min(shift, max(beta_C[calib$idx$idx_brown] - 1e-8, 0))
      beta_C[calib$idx$idx_brown] <- beta_C[calib$idx$idx_brown] - shift
      beta_C[calib$idx$idx_green] <- beta_C[calib$idx$idx_green] + shift
    }

    k <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% beta_C))
    b <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% (calib$beta_G * G_t + calib$I_i0)))
    den <- 1 - c_y * (1 - calib$tau_y) * k
    C_t <- max((c_y * (1 - calib$tau_y) * b + c_v * V_prev) / den, 0)

    fd_t <- beta_C * C_t + calib$beta_G * G_t + calib$I_i0
    x_t <- pmax(as.numeric(calib$L %*% fd_t), 0)
    Y_t <- sum(calib$va_coeff * x_t)
    TAX_t <- calib$tau_y * Y_t
    YD_t <- Y_t - TAX_t

    V_t <- V_prev + YD_t - C_t
    DEF_t <- G_t - TAX_t
    B_t <- B_prev + DEF_t

    out[tt, c("GDP", "TAX", "YD", "C", "G", "V", "DEF", "B", "betaC_brown", "betaC_green")] <- c(
      Y_t, TAX_t, YD_t, C_t, G_t, V_t, DEF_t, B_t,
      if (is.finite(calib$idx$idx_brown)) beta_C[calib$idx$idx_brown] else NA_real_,
      if (is.finite(calib$idx$idx_green)) beta_C[calib$idx$idx_green] else NA_real_
    )

    x_prev <- x_t
    V_prev <- V_t
    B_prev <- B_t
    G_prev <- G_t
  }

  out
}
```

Core play: transition speed.

Increase endogenous transition speed from zero.
Rerun the model and compare GDP against Step 2 no-transition baseline.
```{r step3_play_core_transition_speed}
transition_speed_play <- 0.004  # @exercise[id=step3_speed;kind=core;question_expr=0.001;prompt="Change endogenous transition speed and compare GDP/energy-share paths";hint="Try 0.001 then 0.004"]
step3_play <- simulate_sim_iot_endogenous_transition(calib3, T = 20, transition_speed = transition_speed_play)
```

Plot Step 3 core comparison.

Overlay baseline and transition GDP paths to isolate the endogenous transition effect.
```{r step3_plot_core, fig.height=4, fig.width=7}
plot(step2_baseline$year, step2_baseline$GDP, type = "l", lwd = 2, col = "steelblue",
     xlab = "year", ylab = "GDP", main = "Step 3 Core Play: transition speed")
lines(step3_play$year, step3_play$GDP, lwd = 2, col = "firebrick")
legend("topleft", legend = c("baseline (no transition)", paste0("play: ", transition_speed_play)),
       col = c("steelblue", "firebrick"), lty = 1, bty = "n")
```

Optional play: transition asymmetry / signal sensitivity.

Change the signal weight in the endogenous rule and compare brown/green share dynamics.
```{r step3_play_optional_signal}
transition_signal_weight_play <- 1.8  # @exercise[id=step3_signal;kind=optional;question_expr=0.5;prompt="Change transition signal sensitivity and compare brown/green share dynamics";hint="Try 0.5, 1.0, 1.8"]
step3_opt <- simulate_sim_iot_endogenous_transition(calib3, T = 20, transition_speed = transition_speed_play, transition_signal_weight = transition_signal_weight_play)

plot(step3_play$year, step3_play$betaC_brown, type = "l", lwd = 2, col = "firebrick",
     xlab = "year", ylab = "beta_C shares", main = "Step 3 Optional: signal sensitivity")
lines(step3_opt$year, step3_opt$betaC_brown, lwd = 2, col = "firebrick", lty = 2)
lines(step3_play$year, step3_play$betaC_green, lwd = 2, col = "darkgreen")
lines(step3_opt$year, step3_opt$betaC_green, lwd = 2, col = "darkgreen", lty = 2)
legend("right", legend = c("brown base", "brown play", "green base", "green play"),
       col = c("firebrick", "firebrick", "darkgreen", "darkgreen"), lty = c(1, 2, 1, 2), bty = "n")
```

### Interpretation

Step 3 introduces a separate endogenous-transition algorithm on top of the Step 2 baseline dynamics.
