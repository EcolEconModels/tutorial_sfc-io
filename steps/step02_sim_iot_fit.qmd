---
title: "Step 2 - SIM + IOT Baseline Fit"
format:
  html:
    toc: true
    number-sections: true
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
---

## Shared Setup

Load minimal packages and global options only.

Check that required packages are installed.
Stop early with a clear error if anything is missing.
This keeps the tutorial run deterministic and minimal.
```{r setup_packages}
required_packages <- c("jsonlite", "ggplot2")
missing_packages <- required_packages[!vapply(required_packages, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_packages) > 0) {
  stop("Missing package(s): ", paste(missing_packages, collapse = ", "), call. = FALSE)
}
```

### Dependency Context

This step is standalone: it sources only shared loaders/parsers/calibration helpers.
Dynamics are defined in this step file (not in helpers).

```{r source_helpers}
helper_dir <- if (dir.exists('R/helpers')) 'R/helpers' else '../R/helpers'
source(file.path(helper_dir, 'cache_io.R'))
source(file.path(helper_dir, 'jsonstat_parse.R'))
source(file.path(helper_dir, 'iot_load.R'))
source(file.path(helper_dir, 'config_wealth.R'))
source(file.path(helper_dir, 'calibration.R'))
```

## Step 2: SIM + IOT Baseline Fit

### Objective

Integrate SIM stocks-flows with IOT production, fit to base-year data, and simulate a 20-year no-transition baseline.

### Equations

- `x_t = L f_t`
- `Y_t = sum_i(v_i x_i,t)`
- `T_t = tau_y * Y_t`
- `C_t = c_y * YD_t + c_v * V_{t-1}`
- `V_t = V_{t-1} + YD_t - C_t`
- `DEF_t = G_t - T_t`, `B_t = B_{t-1} + DEF_t`

### TFM (Step 2 additions first)

| Flow | Households | Government | Production (IOT aggregate) | Sum |
|---|---:|---:|---:|---:|
| Disposable income `YD` | `+YD` | `0` | `-YD` | `0` |
| Taxes `T` | `-T` | `+T` | `0` | `0` |
| Consumption `C` | `-C` | `0` | `+C` | `0` |
| Government demand `G` | `0` | `-G` | `+G` | `0` |
| Capital demand `I` | `0` | `0` | `+I` | `+I` exogenous in closure |

### BSM (Step 2 stock mapping)

| Stock | Households | Government | Sum |
|---|---:|---:|---:|
| Wealth / bills `V (=B)` | `+V` | `-B` | `0` |

Step 2 change vs Step 1: production is mapped through the IOT (`x = Lf`), while stock-flow closure remains the SIM wealth/debt core.

### Helper Excerpts (First Introduction)

These helpers are first used here. We keep full helper code in `R/helpers/`, and show excerpts so participants see the exact algorithmic logic.

Cache/download helper (`R/helpers/cache_io.R`): build deterministic query URLs, cache JSON locally, and reuse cache on reruns.

```r
fetch_eurostat_json <- function(dataset_id, params, cache_dir = "data") {
  cache_file <- cache_file_for_query(dataset_id, params, cache_dir)
  if (file.exists(cache_file)) return(jsonlite::read_json(cache_file, simplifyVector = FALSE))
  url <- paste0(base, "/", dataset_id, "?", paste(build_query_parts(params), collapse = "&"))
  utils::download.file(url, destfile = cache_file, mode = "wb", quiet = TRUE)
  jsonlite::read_json(cache_file, simplifyVector = FALSE)
}
```

JSON-stat parser excerpt (`R/helpers/jsonstat_parse.R`): decode sparse Eurostat values into a dense matrix with ordered row/column categories.

```r
extract_matrix_from_json <- function(js, row_dim, col_dim) {
  row_cat <- ordered_categories(js[["dimension"]][[row_dim]])
  col_cat <- ordered_categories(js[["dimension"]][[col_dim]])
  M <- matrix(NA_real_, nrow = nrow(row_cat), ncol = nrow(col_cat))
  for (j in seq_along(flat_idx)) {
    pos <- decode_jsonstat_index(flat_idx[j], sizes)
    M[pos[row_i] + 1L, pos[col_i] + 1L] <- as.numeric(vals[[j]])
  }
  list(M = M, row_cat = row_cat, col_cat = col_cat)
}
```

IOT calibration excerpt (`R/helpers/iot_load.R`): extract `Z`, compute `A`, invert for `L`, and build base demand/value-added vectors.

```r
Z <- mat$M[r_idx, c_idx, drop = FALSE]
A0 <- sweep(Z, 2, pmax(x0, 1e-9), '/')
L0 <- solve(diag(length(sector_codes)) - A0 + diag(1e-8, length(sector_codes)))
C_i0 <- sum_matching_cols(Msel, col_codes, col_labels, c('^P3_S14$', 'households'))
G_i0 <- sum_matching_cols(Msel, col_codes, col_labels, c('^P3_S13$', 'government'))
va_coeff <- as.numeric(mat$M[va_row[1], c_idx, drop = TRUE]) / pmax(x0, 1e-9)
```

### Configuration and Fit Workflow

Declare one core data configuration and keep it consistent across loading, wealth initialization, and calibration.

```{r step2_run_config}
core_config <- make_core_config()
```

Calibrate SIM+IOT from Step 2 data.

Load IO and wealth for the configured country/year/table choice.
Build one calibration object (`calib3`) that stores coefficients and initial stocks.
This calibrated object is reused in Step 3 and Step 4.
```{r step2_run_calibrate}
if (!exists("core_iot", inherits = FALSE) || !identical(core_iot$country, core_config$country) || !identical(core_iot$scope, core_config$scope) || !identical(core_iot$table_type, core_config$table_type) || !identical(as.integer(core_iot$base_year), as.integer(core_config$year))) {
  core_iot <- download_or_load_iot(core_config)
}
if (!exists("core_wealth", inherits = FALSE) || !is.list(core_wealth) || !all(c("V0", "B0") %in% names(core_wealth))) {
  core_wealth <- load_wealth_init(core_config)
}
calib3 <- calibrate_sim_iot(core_iot, core_wealth)
```

Define Step 2 baseline dynamics (no transition in this step).

This is the Step 2 algorithm to be learned: fiscal + household behavior + IO production, without any energy-share reallocation term.
`C_t` is solved each period from the reduced form, then mapped to sector output via `L`.
```{r step2_functions_baseline}
simulate_sim_iot_baseline <- function(calib,
                                      T = 20,
                                      c_y = 0.82,
                                      c_v = 0.03,
                                      g_G = 0.01) {
  years <- calib$base_year + seq_len(T) - 1
  out <- data.frame(
    year = years,
    GDP = NA_real_, TAX = NA_real_, YD = NA_real_, C = NA_real_, G = NA_real_,
    V = NA_real_, DEF = NA_real_, B = NA_real_
  )

  V_prev <- calib$V0
  B_prev <- calib$B0
  G_prev <- calib$G0

  for (tt in seq_len(T)) {
    G_t <- if (tt == 1) calib$G0 else G_prev * (1 + g_G)

    k <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% calib$beta_C))
    b <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% (calib$beta_G * G_t + calib$I_i0)))
    den <- 1 - c_y * (1 - calib$tau_y) * k
    C_t <- max((c_y * (1 - calib$tau_y) * b + c_v * V_prev) / den, 0)

    fd_t <- calib$beta_C * C_t + calib$beta_G * G_t + calib$I_i0
    x_t <- pmax(as.numeric(calib$L %*% fd_t), 0)
    Y_t <- sum(calib$va_coeff * x_t)
    TAX_t <- calib$tau_y * Y_t
    YD_t <- Y_t - TAX_t

    V_t <- V_prev + YD_t - C_t
    DEF_t <- G_t - TAX_t
    B_t <- B_prev + DEF_t

    out[tt, c("GDP", "TAX", "YD", "C", "G", "V", "DEF", "B")] <- c(Y_t, TAX_t, YD_t, C_t, G_t, V_t, DEF_t, B_t)

    V_prev <- V_t
    B_prev <- B_t
    G_prev <- G_t
  }

  out
}
```

Run 20-year baseline simulation.

This is the no-transition baseline used for Step 3 comparisons.
```{r step2_run_baseline}
step2_baseline <- simulate_sim_iot_baseline(calib3, T = 20)
```

Core play: fiscal stance in baseline (no transition).

Change government spending growth and compare output/debt paths.
```{r step2_play_core_fiscal}
g_G_play <- 0.03  # @exercise[id=step2_gG;kind=core;question_expr=0.00;prompt="Change baseline government spending growth and compare GDP/debt paths";hint="Try 0.00, 0.01, 0.03"]
step2_core_play <- simulate_sim_iot_baseline(calib3, T = 20, g_G = g_G_play)
```

Plot Step 2 core comparison.

Left panel: GDP baseline vs play.
Right panel: government debt baseline vs play.
```{r step2_plot_core, fig.height=4, fig.width=7}
par(mfrow = c(1, 2))
plot(step2_baseline$year, step2_baseline$GDP, type = "l", lwd = 2, col = "steelblue",
     xlab = "year", ylab = "GDP", main = "Step 2 Core: GDP")
lines(step2_core_play$year, step2_core_play$GDP, lwd = 2, col = "firebrick")
legend("topleft", legend = c("baseline", paste0("g_G=", g_G_play)), col = c("steelblue", "firebrick"), lty = 1, bty = "n")
plot(step2_baseline$year, step2_baseline$B, type = "l", lwd = 2, col = "steelblue",
     xlab = "year", ylab = "Gov debt B", main = "Step 2 Core: Debt")
lines(step2_core_play$year, step2_core_play$B, lwd = 2, col = "firebrick")
par(mfrow = c(1, 1))
```

Optional play: baseline wealth-consumption behavior.

Change consumption out of wealth and inspect the wealth path.
```{r step2_play_optional_cv}
c_v_baseline_play <- 0.06  # @exercise[id=step2_cv;kind=optional;question_expr=0.01;prompt="Change baseline c_v and inspect wealth and GDP without transition";hint="Keep baseline dynamics (no transition)"]
step2_opt <- simulate_sim_iot_baseline(calib3, T = 20, c_v = c_v_baseline_play)

ggplot2::ggplot(step2_opt, ggplot2::aes(year, V)) +
  ggplot2::geom_line(linewidth = 1, color = "darkgreen") +
  ggplot2::labs(title = "Step 2 Optional: household wealth path (no transition)", y = "V") +
  ggplot2::theme_minimal()
```

### Interpretation

Step 2 fits SIM+IOT and runs the baseline dynamics without any transition mechanism.
