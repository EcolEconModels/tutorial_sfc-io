---
title: "Step 2 - SIM + IOT Baseline Fit"
format:
  html:
    toc: true
    number-sections: true
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
---

## Shared Setup

Load minimal packages and global options only.

Check that required packages are installed.
Stop early with a clear error if anything is missing.
This keeps the tutorial run deterministic and minimal.
```{r setup_packages}
required_packages <- c("jsonlite", "ggplot2")
missing_packages <- required_packages[!vapply(required_packages, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_packages) > 0) {
  stop("Missing package(s): ", paste(missing_packages, collapse = ", "), call. = FALSE)
}
```

### Dependency Context

This step is standalone: it sources only shared loaders/parsers/calibration helpers.
Dynamics are defined in this step file (not in helpers).

```{r source_helpers}
helper_dir <- if (dir.exists('R/helpers')) 'R/helpers' else '../R/helpers'
source(file.path(helper_dir, 'cache_io.R'))
source(file.path(helper_dir, 'jsonstat_parse.R'))
source(file.path(helper_dir, 'iot_load.R'))
source(file.path(helper_dir, 'config_wealth.R'))
source(file.path(helper_dir, 'calibration.R'))
```

## Step 2: SIM + IOT Baseline Fit

### Objective

Integrate SIM stocks-flows with IOT production, fit to base-year data, and simulate a 20-year no-transition baseline.

### Equations

Step 2 adds explicit production structure from the symmetric IOT.  
The production block is built once from the base year and then used every simulation year to map final demand to sector output.

IO construction and production mapping:
- Technical coefficients from base-year transactions: `A_ij = Z_ij / x_j`
- Leontief inverse: `L = (I - A)^(-1)`
- Sector final demand vector: `f_i,t = C_i,t + G_i,t + I_i`
- Demand shares: `C_i,t = beta_C,i * C_t`, `G_i,t = beta_G,i * G_t`
- Sector output: `x_t = L f_t`
- GDP/value-added aggregation: `Y_t = sum_i(v_i * x_i,t)`

SIM block coupled to IO block:
- Taxes and disposable income: `T_t = tau_y * Y_t`, `YD_t = Y_t - T_t`
- Consumption behavior: `C_t = c_y * YD_t + c_v * V_{t-1}`
- Wealth/debt accumulation: `V_t = V_{t-1} + YD_t - C_t`, `DEF_t = G_t - T_t`, `B_t = B_{t-1} + DEF_t`

Economic meaning of symbols:
- `Z_ij`: intermediate sale from sector `i` to sector `j` in the observed IOT.
- `x_j`: gross output of sector `j`; dividing each column of `Z` by `x_j` gives input requirements per unit output.
- `A`: fixed-coefficient production technology matrix (Leontief technology assumption).
- `L`: total direct+indirect production requirements for one unit of final demand.
- `f_t`: sectoral final demand vector used by production; in this step it combines households, government, and exogenous investment.
- `beta_C,i`, `beta_G,i`: sectoral composition weights that map aggregate `C_t` and `G_t` into sector vectors.
- `v_i`: value-added share in sector `i`, used to aggregate `x_t` to GDP proxy.
- `tau_y`, `c_y`, `c_v`: effective tax rate and household behavioral propensities.
- `V_t`, `B_t`: household net financial wealth and government debt (equal in this two-sector financial closure).

### TFM (Step 2 additions first)

| Flow | Households | Government | Production (IOT aggregate) | Sum |
|---|---:|---:|---:|---:|
| Income `Y` | `+Y` | `0` | `-Y` | `0` |
| Taxes `T` | `-T` | `+T` | `0` | `0` |
| Consumption `C` | `-C` | `0` | `+C` | `0` |
| Government demand `G` | `0` | `-G` | `+G` | `0` |
| Change in wealth/debt `Delta_V (= Delta_B)` | `-Delta_V` | `+Delta_B` | `0` | `0` |

From column sums:
- Households: `Y - T - C - Delta_V = 0`, so `Delta_V = YD - C` with `YD = Y - T`.
- Government: `T - G + Delta_B = 0`, so `Delta_B = G - T`.
- Production: `-Y + C + G = 0`, so `Y = C + G`.
- Stock-flow consistency: `Delta_V = Delta_B`.

How this relates to IO sector detail:
- Aggregated production flow `Y` equals sector-summed value added: `Y = sum_i(v_i * x_i)`.
- Aggregated `C` and `G` are composed from sector vectors `C_i = beta_C,i * C`, `G_i = beta_G,i * G`.
- A fully sector-expanded TFM would replace one production column by `n` sector columns and show each `C_i`, `G_i`, `I_i`, and intermediate deliveries `Z_ij`; the table shown here is its compact aggregate projection.

Investment `I` is treated as exogenous final demand in the IO block and is not represented as a separate institutional column in this minimal TFM.

### BSM (Step 2 stock mapping)

| Stock | Households | Government | Sum |
|---|---:|---:|---:|
| Wealth / bills `V (=B)` | `+V` | `-B` | `0` |

Net-worth identities (column-sum closure):
- `NW_h = V`
- `NW_g = -B`
- with `V = B`, `NW_h + NW_g = 0`

How this relates to sector detail:
- In this minimal closure, production sectors carry no explicit financial assets/liabilities in the BSM.
- A fully sector-expanded BSM could assign firm equity/debt per sector `i`; aggregate net worth would still sum to zero across sectors and institutions.

Step 2 change vs Step 1: production is mapped through the IOT (`x = Lf`), while stock-flow closure remains the SIM wealth/debt core.

### Helper Excerpts (First Introduction)

These helpers are first used here. We keep full helper code in `R/helpers/`, and show excerpts so participants see the exact algorithmic logic.

Cache/download helper (`R/helpers/cache_io.R`): build deterministic query URLs, cache JSON locally, and reuse cache on reruns.

```r
fetch_eurostat_json <- function(dataset_id, params, cache_dir = "data") {
  cache_file <- cache_file_for_query(dataset_id, params, cache_dir)
  if (file.exists(cache_file)) return(jsonlite::read_json(cache_file, simplifyVector = FALSE))
  url <- paste0(base, "/", dataset_id, "?", paste(build_query_parts(params), collapse = "&"))
  utils::download.file(url, destfile = cache_file, mode = "wb", quiet = TRUE)
  jsonlite::read_json(cache_file, simplifyVector = FALSE)
}
```

JSON-stat parser excerpt (`R/helpers/jsonstat_parse.R`): decode sparse Eurostat values into a dense matrix with ordered row/column categories.

```r
extract_matrix_from_json <- function(js, row_dim, col_dim) {
  row_cat <- ordered_categories(js[["dimension"]][[row_dim]])
  col_cat <- ordered_categories(js[["dimension"]][[col_dim]])
  M <- matrix(NA_real_, nrow = nrow(row_cat), ncol = nrow(col_cat))
  for (j in seq_along(flat_idx)) {
    pos <- decode_jsonstat_index(flat_idx[j], sizes)
    M[pos[row_i] + 1L, pos[col_i] + 1L] <- as.numeric(vals[[j]])
  }
  list(M = M, row_cat = row_cat, col_cat = col_cat)
}
```

IOT calibration excerpt (`R/helpers/iot_load.R`): extract `Z`, compute `A`, invert for `L`, and build base demand/value-added vectors.

```r
Z <- mat$M[r_idx, c_idx, drop = FALSE]
A0 <- sweep(Z, 2, pmax(x0, 1e-9), '/')
L0 <- solve(diag(length(sector_codes)) - A0 + diag(1e-8, length(sector_codes)))
C_i0 <- sum_matching_cols(Msel, col_codes, col_labels, c('^P3_S14$', 'households'))
G_i0 <- sum_matching_cols(Msel, col_codes, col_labels, c('^P3_S13$', 'government'))
va_coeff <- as.numeric(mat$M[va_row[1], c_idx, drop = TRUE]) / pmax(x0, 1e-9)
```

### Configuration and Fit Workflow

Declare one core data configuration and keep it consistent across loading, wealth initialization, and calibration.

```{r step2_run_config}
core_config <- make_core_config()
```

Calibrate SIM+IOT from Step 2 data.

Load IO and wealth for the configured country/year/table choice.
Build one calibration object (`calib3`) that stores coefficients and initial stocks.
This calibrated object is reused in Step 3 and Step 4.
```{r step2_run_calibrate}
if (!exists("core_iot", inherits = FALSE) || !identical(core_iot$country, core_config$country) || !identical(core_iot$scope, core_config$scope) || !identical(core_iot$table_type, core_config$table_type) || !identical(as.integer(core_iot$base_year), as.integer(core_config$year))) {
  core_iot <- download_or_load_iot(core_config)
}
if (!exists("core_wealth", inherits = FALSE) || !is.list(core_wealth) || !all(c("V0", "B0") %in% names(core_wealth))) {
  core_wealth <- load_wealth_init(core_config)
}
calib3 <- calibrate_sim_iot(core_iot, core_wealth)
```

Define Step 2 baseline dynamics (no transition in this step).

This is the Step 2 algorithm to be learned: fiscal + household behavior + IO production, without any energy-share reallocation term.
`C_t` is solved each period from the reduced form, then mapped to sector output via `L`.
```{r step2_functions_baseline}
simulate_sim_iot_baseline <- function(calib,
                                      T = 20,
                                      c_y = 0.82,
                                      c_v = 0.03,
                                      g_G = 0.01) {
  years <- calib$base_year + seq_len(T) - 1
  out <- data.frame(
    year = years,
    GDP = NA_real_, TAX = NA_real_, YD = NA_real_, C = NA_real_, G = NA_real_,
    V = NA_real_, DEF = NA_real_, B = NA_real_
  )

  V_prev <- calib$V0
  B_prev <- calib$B0
  G_prev <- calib$G0

  for (tt in seq_len(T)) {
    G_t <- if (tt == 1) calib$G0 else G_prev * (1 + g_G)

    k <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% calib$beta_C))
    b <- as.numeric(t(calib$va_coeff) %*% (calib$L %*% (calib$beta_G * G_t + calib$I_i0)))
    den <- 1 - c_y * (1 - calib$tau_y) * k
    C_t <- max((c_y * (1 - calib$tau_y) * b + c_v * V_prev) / den, 0)

    fd_t <- calib$beta_C * C_t + calib$beta_G * G_t + calib$I_i0
    x_t <- pmax(as.numeric(calib$L %*% fd_t), 0)
    Y_t <- sum(calib$va_coeff * x_t)
    TAX_t <- calib$tau_y * Y_t
    YD_t <- Y_t - TAX_t

    V_t <- V_prev + YD_t - C_t
    DEF_t <- G_t - TAX_t
    B_t <- B_prev + DEF_t

    out[tt, c("GDP", "TAX", "YD", "C", "G", "V", "DEF", "B")] <- c(Y_t, TAX_t, YD_t, C_t, G_t, V_t, DEF_t, B_t)

    V_prev <- V_t
    B_prev <- B_t
    G_prev <- G_t
  }

  out
}
```

Run 20-year baseline simulation.

This is the no-transition baseline used for Step 3 comparisons.
```{r step2_run_baseline}
step2_baseline <- simulate_sim_iot_baseline(calib3, T = 20)
```

Core play: fiscal stance in baseline (no transition).

Change government spending growth and compare output/debt paths.
```{r step2_play_core_fiscal}
g_G_play <- 0.03  # @exercise[id=step2_gG;kind=core;question_expr=0.00;prompt="Change baseline government spending growth and compare GDP/debt paths";hint="Try 0.00, 0.01, 0.03"]
step2_core_play <- simulate_sim_iot_baseline(calib3, T = 20, g_G = g_G_play)
```

Plot Step 2 core comparison.

Left panel: GDP baseline vs play.
Right panel: government debt baseline vs play.
```{r step2_plot_core, fig.height=4, fig.width=7}
par(mfrow = c(1, 2))
plot(step2_baseline$year, step2_baseline$GDP, type = "l", lwd = 2, col = "steelblue",
     xlab = "year", ylab = "GDP", main = "Step 2 Core: GDP")
lines(step2_core_play$year, step2_core_play$GDP, lwd = 2, col = "firebrick")
legend("topleft", legend = c("baseline", paste0("g_G=", g_G_play)), col = c("steelblue", "firebrick"), lty = 1, bty = "n")
plot(step2_baseline$year, step2_baseline$B, type = "l", lwd = 2, col = "steelblue",
     xlab = "year", ylab = "Gov debt B", main = "Step 2 Core: Debt")
lines(step2_core_play$year, step2_core_play$B, lwd = 2, col = "firebrick")
par(mfrow = c(1, 1))
```

Optional play: baseline wealth-consumption behavior.

Change consumption out of wealth and inspect the wealth path.
```{r step2_play_optional_cv}
c_v_baseline_play <- 0.06  # @exercise[id=step2_cv;kind=optional;question_expr=0.01;prompt="Change baseline c_v and inspect wealth and GDP without transition";hint="Keep baseline dynamics (no transition)"]
step2_opt <- simulate_sim_iot_baseline(calib3, T = 20, c_v = c_v_baseline_play)

ggplot2::ggplot(step2_opt, ggplot2::aes(year, V)) +
  ggplot2::geom_line(linewidth = 1, color = "darkgreen") +
  ggplot2::labs(title = "Step 2 Optional: household wealth path (no transition)", y = "V") +
  ggplot2::theme_minimal()
```

### Interpretation

Step 2 fits SIM+IOT and runs the baseline dynamics without any transition mechanism.
