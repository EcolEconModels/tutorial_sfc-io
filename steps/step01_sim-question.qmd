---
title: "Step 1 - SIM"
format:
  html:
    toc: true
    number-sections: true
    embed-resources: true
execute:
  echo: true
  warning: false
  message: false
---

## Shared Setup

Load minimal packages and global options only.

Check that required packages are installed.
Stop early with a clear error if anything is missing.
This keeps the tutorial run deterministic and minimal.
```{r setup_packages}
required_packages <- c("jsonlite", "ggplot2")
missing_packages <- required_packages[!vapply(required_packages, requireNamespace, logical(1), quietly = TRUE)]
if (length(missing_packages) > 0) {
  stop("Missing package(s): ", paste(missing_packages, collapse = ", "), call. = FALSE)
}
```


## Step 1: SIM Closed Model (Chapter 3 of Godley & Lavoie 2012 book)

### Objective

Build a simple (SIM) SFC model with Government, Production and Household sectors.
We see that GDP and Wealth reach a steady state after some time!
Depending on whether consumption behaviour depends on current year vs previous year income,
 we need to solve differently

### Equations

- Output identity `Y_t = C_t + G_t`
- Taxes `T_t = theta * Y_t`
- Household Disposable Income `YD_t = Y_t - T_t`
- Consumption `C_t(lag) = alpha1 * YD_{t-1} + alpha2 * H_{t-1}` , (assume based on last year's income, SIM-lag)
- Consumption `C_t(current) = alpha1 * YD_t + alpha2 * H_{t-1}` , (assume based on current year's income, SIM-current)
- Household Wealth / change in wealth `H_t = H_{t-1} + YD_t - C_t`
- Government deficit/debt: `DEF_t = G_t - T_t`, `B_t = B_{t-1} + DEF_t`
- Fixed point of GDP: `Y* = G / theta`

Transaction Flow Matrix (TFM, one period, sign by sector column):

| Flow | Households | Government | Production | Sum |
|---|---:|---:|---:|---:|
| Wages / income `Y` | `+Y` | `0` | `-Y` | `0` |
| Taxes `T` | `-T` | `+T` | `0` | `0` |
| Consumption `C` | `-C` | `0` | `+C` | `0` |
| Government demand `G` | `0` | `-G` | `+G` | `0` |

From column sums:
- Households: `Delta H = YD - C = Y - T - C`
- Government: `Delta B = G - T`
- Production: `Y = C + G`

Balance Sheet Matrix (BSM, simplified SIM view):

|                 | Households | Government | Production | Sum |
|---|---:|---:|---:|---:|
| Government bills / money `H (=B)` | `+H` | `-B` | `0` | `0` |
| Net worth              | `V_h` | `V_g` | `V_p` | `0` |

Steady-state derivation (SIM):
- At steady state, stocks are constant: `H_t = H_{t-1} = H*` so `0 = YD* - C*`, hence `C* = YD* = (1-theta)Y*`.
- GDP: `Y* = C* + G = (1-theta)Y* + G*`.
- Rearranging: `theta * Y* = G`, so `Y* = G / theta`.
- From behavior at steady state: `C* = alpha1*(1-theta)Y* + alpha2*H*` and `C* = (1-theta)Y*`.
- Therefore: `H* = ((1-alpha1)*(1-theta)/alpha2) * Y* = ((1-alpha1)*(1-theta)/alpha2) * (G/theta)`.
- The fixed-point GDP `Y*` is independent of `alpha1` and `alpha2`; those affect only transition dynamics.

SIM-lag is easy to simulate, since all updates depend on previous year's values, so no circular depndencies

Define the SIM-lag dynamics as a simple time loop.
Consumption `C_t(lag) = alpha1 * YD_{t-1} + alpha2 * H_{t-1}` depends on lagged disposable income and past wealth.
The function simulates the dynamics for time steps `T` (years), and returns a time-series for plotting and comparisons.
```{r step1_functions_sim_core}
simulate_sim_lag <- function(T = 20, G = 100, theta = 0.2, alpha1 = 0.6, alpha2 = 0.2, Y0 = 80, H0 = 300) {
  out <- data.frame(t = seq_len(T), Y = NA_real_, T_tax = NA_real_, YD = NA_real_, C = NA_real_, H = NA_real_)
  YD_prev <- (1 - theta) * Y0
  H_prev <- H0
  for (tt in seq_len(T)) {
    C_t <- alpha1 * YD_prev + alpha2 * H_prev
    Y_t <- C_t + G
    T_t <- theta * Y_t
    YD_t <- Y_t - T_t
    H_t <- H_prev + YD_t - C_t
    out[tt, c("Y", "T_tax", "YD", "C", "H")] <- c(Y_t, T_t, YD_t, C_t, H_t)
    YD_prev <- YD_t
    H_prev <- H_t
  }
  out
}
```

Run SIM-lag from intial values that are below the steady state.

Set baseline SIM parameters and compute the fixed point Y*.
Choose an initial GDP below Y* and derive a consistent H0.
Run the lag model to generate the convergence path.
```{r step1_run_lag_below}
T_h <- 40 # time horizon
G <- 100  # government spending per year
theta <- 0.2 # tax rate
alpha1 <- 0.6 # fraction consumption out of income
alpha2 <- 0.2 # fraction consumption out of wealth
# fixed points for GDP and wealth
Y_star <- G / theta
H_star <- ((1 - alpha1) * (1 - theta) * Y_star) / alpha2
# setting Y0 below the fixed point, try above as well!
Y0_low <- 0.7 * Y_star
# setting H0 consistent with Y0, try something else, e.g. 0.0 as well!
H0_low <- (Y0_low * (1 - alpha1 * (1 - theta)) - G) / alpha2
# also define above-fixed-point initial values for comparison plots
Y0_high_play <- 1.3 * Y_star
H0_high_play <- (Y0_high_play * (1 - alpha1 * (1 - theta)) - G) / alpha2
lag_low <- simulate_sim_lag(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2, Y0 = Y0_low, H0 = H0_low)
lag_low$DEF <- G - lag_low$T_tax
lag_low$H_from_DEF <- H0_low + cumsum(lag_low$DEF)
```


SIM-current is not so easy to simulate, since updates are circular!
Consumption `C_t(current) = alpha1 * YD_t + alpha2 * H_{t-1}` depends on current disposable income and past wealth.
Current disposable income `YD_t` depends on current output.

Define SIM-current with within-period fixed-point iteration.
Each period solves Y from current disposable income and wealth.
This makes incomeâ€“consumption contemporaneous instead of lagged.
```{r step1_functions_sim_current}
simulate_sim_current_fp <- function(T = 20, G = 100, theta = 0.2, alpha1 = 0.6, alpha2 = 0.2,
                                    Y0 = 80, H0 = 300, fp_tol = 1e-10, fp_max = 200) {
  out <- data.frame(t = seq_len(T), Y = NA_real_, T_tax = NA_real_, YD = NA_real_, C = NA_real_, H = NA_real_)
  H_prev <- H0
  Y_prev <- Y0
  for (tt in seq_len(T)) {
    Y_guess <- Y_prev
    n_iter <- 0L
    repeat {
      n_iter <- n_iter + 1L
      Y_new <- G + alpha1 * (1 - theta) * Y_guess + alpha2 * H_prev
      if (abs(Y_new - Y_guess) < fp_tol || n_iter >= fp_max) break
      Y_guess <- Y_new
    }
    Y_t <- Y_new
    T_t <- theta * Y_t
    YD_t <- Y_t - T_t
    C_t <- alpha1 * YD_t + alpha2 * H_prev
    H_t <- H_prev + YD_t - C_t
    out[tt, c("Y", "T_tax", "YD", "C", "H")] <- c(Y_t, T_t, YD_t, C_t, H_t)
    H_prev <- H_t
    Y_prev <- Y_t
  }
  out
}
```

Compare lag and current dynamics.

Run SIM-current from below and above the fixed point.
Plot lag and current dynamics together for comparison.
This shows how timing assumptions affect transients.
```{r step1_run_compare_lag_current}
lag_high_play <- simulate_sim_lag(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2, Y0 = Y0_high_play, H0 = H0_high_play)
cur_low <- simulate_sim_current_fp(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2, Y0 = Y0_low, H0 = H0_low)
cur_high <- simulate_sim_current_fp(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2, Y0 = Y0_high_play, H0 = H0_high_play)

yr <- range(c(lag_low$Y, lag_high_play$Y, cur_low$Y, cur_high$Y, Y_star), na.rm = TRUE)
pad <- 0.05 * diff(yr); if (!is.finite(pad) || pad <= 0) pad <- 1
plot(lag_low$t, lag_low$Y, type = "l", lwd = 2, col = "steelblue",
     ylim = c(yr[1] - pad, yr[2] + pad),
     xlab = "t", ylab = "GDP", main = "Step 1C: SIM-lag vs SIM-current")
lines(lag_high_play$t, lag_high_play$Y, lwd = 2, col = "firebrick")
lines(cur_low$t, cur_low$Y, lwd = 2, col = "darkgreen")
lines(cur_high$t, cur_high$Y, lwd = 2, col = "purple4")
abline(h = Y_star, lty = 2)
legend("right", legend = c("Lag below", "Lag above", "Current below", "Current above", "Y*"),
       col = c("steelblue", "firebrick", "darkgreen", "purple4", "black"),
       lty = c(1, 1, 1, 1, 2), bty = "n")
```

Optional play: adjust wealth propensity in both variants.

Vary the propensity to consume out of wealth (alpha2).
Rerun both lag and current versions with the new alpha2.
Plot the impact on speed of convergence.
```{r step1_play_optional_alpha2}
alpha2_play <- 0.1  # TODO [optional:step1_alpha2] Change alpha2 and compare speed of convergence Hint: Lower alpha2 usually slows wealth-driven demand

lag_opt <- simulate_sim_lag(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2_play, Y0 = Y0_low, H0 = H0_low)
cur_opt <- simulate_sim_current_fp(T = T_h, G = G, theta = theta, alpha1 = alpha1, alpha2 = alpha2_play, Y0 = Y0_low, H0 = H0_low)

plot(lag_opt$t, lag_opt$Y, type = "l", lwd = 2, col = "steelblue",
     xlab = "t", ylab = "GDP", main = "Step 1 Optional: effect of alpha2")
lines(cur_opt$t, cur_opt$Y, lwd = 2, col = "darkgreen")
legend("right", legend = c("Lag", "Current"), col = c("steelblue", "darkgreen"), lty = 1, bty = "n")
```

### Interpretation

Both dynamic versions converge to the same fixed point, but with different transient paths.
